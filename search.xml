<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang中的方法]]></title>
    <url>%2F2019%2F09%2F12%2Fmethod%2F</url>
    <content type="text"><![CDATA[Golang中的方法Golang并非是面向对象的语言，但是它可以模拟面向对象。Golang中的struct就类似于面向对象语言中的类，那么既然有了类，就要有对应的类的方法。Golang中以接收器（reciever）的形式实现struct的方法。1.方法的声明方法声明的形式如下1234type mytype struct &#123;&#125;func (m mytype) method(para) return_type &#123;&#125;func (m *mytype) method(para) return_type &#123;&#125; 这就表示方法method是绑定在mytype上的，就类似于面向对象语言中类的成员方法 下面是一个实例 123456789101112131415161718192021type Point struct &#123; X, Y float64&#125;func Distance(p, q Point) float64 &#123; return math.Hypot(q.X-p.X, q.Y-p.Y)&#125;//类型Point的方法func (p Point) Distance(q Point) float64 &#123; return math.Hypot(q.X-p.X, q.Y-p.Y)&#125;func main() &#123; p := Point&#123;1, 2&#125; q := Point&#123;4, 6&#125; fmt.Println(Distance(p, q)) //p调用属于类型Point的方法Distance fmt.Println(p.Distance(q))&#125; 以上例子中，虽然声明了两个同名的Distance函数，但是不会报错。因为第一个是属于当前包的包级别函数，第二个是属于Point类的方法。 Go语言中，不同类型可以有相同的方法名，只要定义方法时用接收器区分开就可以。 1234567891011121314type myslice []intfunc (s myslice) sum() int &#123; sum := 0 for _, v := range s &#123; sum += v &#125; return sum&#125;func main() &#123; s := myslice&#123;1, 2, 3&#125; fmt.Println(s.sum())&#125; Go语言中，与面向对象语言不同的是它不仅仅可以为struct定义方法，也可以为type定义的类型别名、slice、map、channel、func类型定义方法。但内置简单数据类型(int、float等)不行，interface类型不行。 上述不可以为简单类型定义方法，可以通过使用type a int这种形式为简单类型定义方法。 面向对象语言中，类的方法要定义在类的内部，Go语言中struct可以与方法的定义分开在不同的文件中，但一定要在一个包内。 方法就是函数，所以Go语言中没有重载的概念，同一类型中所有方法名都必须唯一 2.方法和函数的区别本质上方法就是函数，方法是绑定了类型的特殊函数，需要指定类型的实例才可以调用。 3.值类型和指针类型的接受者如果接收者是一个指针类型，那么同实例化类型一样会自动解除引用 123456789101112//实例化类型type Person struct &#123;name, age int&#125;p := Person&#123;&#125;//值类型的Person实例p1 := new(Person)//指针类型的实例//在需要访问或调用mytype实例属性时候，如果发现它是一个指针类型的变量，Go会自动将其解除引用p.name = "xxs"p1.name = "sdad"//不需要(*p1).name//接收者为指针类型func (a *mytype1) add() ret_type &#123;&#125;a.add()//不需要(*a).add() 方法的接受者有两种类型：值类型和指针类型。它们在使用上有很大的区别 12func (p person) setname(name string) &#123; p.name = name &#125;func (p *person) setage(age int) &#123; p.age = age &#125; 对于setname方法，它的reciever是值类型的，那么在接收参数时是拷贝完整的Person的数据结构，无论实例是值类型还是指针类型，方法内部使用和修改的都是实例的副本，不会影响外部原始副本的值。 对于setage方法，它的reciever是指针类型的，那么在接收参数时是拷贝指针，无论实例是值类型还是指针类型，方法内部使用和修改的都是原始实例的数据。 如下例所示 1234567891011121314151617181920212223242526272829303132333435type Person struct &#123; name string age int&#125;func (p *Person) getname() string &#123; return p.name&#125;func (p *Person) getage() int &#123; return p.age&#125;//这里比较reciever是值类型和指针类型的区别func (p Person) setname(name string) &#123; p.name = name&#125;func (p *Person) setage(age int) &#123; p.age = age&#125;func main() &#123; p1 := Person&#123;&#125; p1.setname("nyx") p1.setage(10) fmt.Println(p1.getname())//输出"" fmt.Println(p1.getage())//输出10 p2 := new(Person) p2.setname("nyx") p2.setage(10) fmt.Println(p2.getname())//输出"" fmt.Println(p2.getage())//输出10&#125; 4.嵌套struct中的方法与属性类似，内部struct的方法也会被嵌套，外部struct可以直接调用内部struct的方法。如果外部struct有方法与内部strcut方法同名，那么直接调用的话就是调用外部strcut的方法，想要调用内部struct的对应方法需要使用间接调用的方式 Go语言的struct支持嵌套多个匿名字段，也就是说一个struct可以有多个内部struct，相当于支持多重继承 5.重写String()方法12345678910111213141516type Person struct &#123; name string age int&#125;func (p *Person) String() string &#123; return p.name + ": " + strconv.Itoa(p.age)&#125;func mian() &#123; p := new(Person) // p := Person&#123;&#125; p.name = "nyx" p.age = 24 fmt.Println(p) //nyx: 24&#125;]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logstash to Logstash Communication]]></title>
    <url>%2F2019%2F09%2F11%2Flogstash%20to%20logstash%20communication%2F</url>
    <content type="text"><![CDATA[Logstash to Logstash Communication 实现logstash与logstash之间的通信需要通过lumberjack插件实现。 1.生成证书执行openssl req -x509 -days 3560 -batch -nodes -newkey rsa:2048 -keyout lumberjack.key -out lumberjack.cert -subj /CN=localhost 生成一个lumberjack.cert 和一个lumberjack.key 使用x509方式创建证书默认有效时间是30天，使用days设置过期时间 2.保存证书将lumberjack.cert保存在upstream logstash所在服务器（docker服务的话就保存在容器中），将lumberjack.key保存在downstream logstash所在服务器（docker服务的话就保存在容器中）。 以docker容器的方式启动logstash： 把私钥和证书保存在同一路径下{local_lumberjack_path} 123docker-compose.yml中volumes: &#123;local_lumberjack_path&#125;: /usr/share/logstash/lumberjack 将私钥、证书放入容器内部 3.logstash 配置建立链接时，upstream logstash使用lumberjack作为output，downstream logstash使用beats作为input，开启ssl认证。 123456789upstream logstash:output&#123; lumberjack &#123; port =&gt; 5001 host =&gt; &quot;**********&quot; ssl =&gt; true ssl_certificate =&gt; &quot;/usr/share/logstash/lumberjack/lumberjack.cert&quot; &#125;&#125; 12345678910downstream logstash:input&#123; beats &#123; port =&gt; 5001 codec =&gt; json ssl =&gt; true ssl_certificate =&gt; &quot;/usr/share/logstash/lumberjack/lumberjack.cert&quot; ssl_key =&gt; &quot;/usr/share/logstash/lumberjack/lumberjack.key&quot; &#125;&#125; 在本项目中，upstream logstash位于aws服务器上，upstream logstash位于广东跳板机上，两台机器通过ssh_tunnel进行通信，端口为5001 upstream logstash的数据由logspout（采集服务的日志）提供，logspout部署在aws swarm上，向upstream开启的监听端口5001发送数据 数据流向：switch -&gt; logspout -&gt; upstream logstash —ssh_tunnel+lumberjack—&gt; downstream logstash]]></content>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 回调函数和闭包]]></title>
    <url>%2F2019%2F09%2F11%2Fgo%2F</url>
    <content type="text"><![CDATA[回调函数和闭包高阶函数 golang中的高阶函数有以下特性： 函数可以作为另一个函数的参数（常用于回调函数） 函数可以作为另一个函数的返回值（常用于闭包） 函数可以被赋值给一个变量 1.函数作为参数12345678910111213141516package mainimport "fmt"func added(msg string, a func(a, b int) int) &#123; fmt.Println(msg, ":", a(33, 44))&#125;func main() &#123; // 函数内部不能嵌套命名函数 // 所以main()中只能定义匿名函数 f := func(a, b int) int &#123; return a + b &#125; added("a+b", f)&#125; 此例中将在main函数中定一个匿名函数，将该函数赋值给变量f，作为参数传入added函数中，added函数会接收一个func(a, b int) int类型的函数作为参数。 这种将函数b作为参数传入函数a的使用方式可以提高函数a的灵活性，只要函数b符合函数a定义的参数类型就可以通过b完成很多不同的功能，因此常用于回调 2.函数作为返回值1234567891011121314151617181920212223242526272829303132333435func squares() func() int &#123;var x int// f := func() int &#123;// x++// return x * x// &#125;// return freturn func() int &#123;x++return x * x&#125;&#125;f2 := squares()fmt.Println(f2()) //1fmt.Println(f2()) //4fmt.Println(f2()) //9fmt.Println(f2()) //16 这里在函数体内部定义一个匿名函数，并且将该匿名函数作为另一个函数的返回值。main函数中将squares函数赋值给变量f2。 每一次打印都会调用一次squares函数，生成一个新的局部变量x，但是匿名函数会记录x的状态，每一次x都是在之前的基础上加1。 函数值就被称为闭包 回调函数go语言中sort包内的SliceStable()就是一个回调函数，它用于给slice中的元素进行排序。该函数定义如下： 12345678func SliceStable(slice interface&#123;&#125;, less func(i, j int) bool)s := []int&#123;112, 22, 52, 32, 12&#125; less := func(i, j int) bool &#123; //按照降序进行排序，可以修改less的实现来进行不同方式的排序 return s[i] &gt; s[j] &#125; sort.SliceStable(s, less) 该函数的第二个参数就是一个func(i, j int) bool类型的名为less的函数。 less方法对已知的slice中的i，j索引对应的元素进行排序。 我们可以通过不同的less函数的实现对slice进行不同的排序方式。 闭包函数a返回函数b的经典场景就是闭包。 闭包 -&gt; 函数+作用域环境 闭包就是包含以上两个要素的特殊函数，它可以访问不是在它内部声明的变量，这个变量位于其他的作用域并且是未赋值的。 12345678910111213141516171819202122package mainimport "fmt"func f(x int) func(int) int&#123; g := func(y int) int&#123; return x+y &#125; // 返回闭包 return g&#125;func main() &#123; // 将函数的返回结果"闭包"赋值给变量a a := f(3) // 调用存储在变量中的闭包函数 res := a(5) fmt.Println(res) // 可以直接调用闭包 // 因为闭包没有赋值给变量，所以它称为匿名闭包 fmt.Println(f(3)(5))&#125; x不在g的作用域内，并且g引用了x，所以g是一个闭包。 如果x在传给g之前就被赋值了，g就不能称为闭包了 闭包特性： 对于每个闭包g来说，不同的g引用不同的x对应的数据对象。或者说f函数的x对应的数据对象对于每个不同的闭包是不一样的。 12a := f(1)b := f(1) 以上a和b是两个闭包，两个闭包中的自由变量的数值都是1，但它们不是同一个数值对象 只要不是匿名闭包，就可以一直访问x对应的同一个数据对象 1234567a := f(1)//a是一个有名称的闭包，会一直引用同一个数值对象1a(3) //调用闭包a，返回1+3=4，1是一直被闭包a引用的数值对象，执行完以后也不会放开a(3) //再次调用闭包a，依旧返回4，调用还是跟上一次调用a时相同的数值对象1f(1)(3) //匿名的闭包，调用完后就会把数值对象1放开f(1)(3) //引用的数值对象1与上一次匿名闭包引用的是不同的数值对象，与上一个匿名闭包相互独立 虽然g()中持有了自由变量，但是g()函数自身不是闭包函数，只有在g持有的自由变量x和传递给f()函数的x的值(即f(1)中的1)进行绑定的时候，才会从g()创建一个闭包函数，这表示闭包函数开始引用这个自由变量，并且这个闭包一直持有这个变量的引用，即使f()已经执行完毕了。 闭包不一定要通过另一个函数返回，可以直接自定义一个闭包,只要它访问了一个不在自己作用域并且尚未被赋值的变量即可。 12345678910111213func main() &#123; // 自由变量x var x int // 闭包函数g g := func(i int) int &#123; return x + i &#125; x = 5 // 调用闭包函数 fmt.Println(g(5)) x = 10 // 调用闭包函数 fmt.Println(g(3)) 闭包的作用：让多个闭包函数共享一个自由变量。 例如在第一个例子中，a := f(3)，给外层的变量x赋值为3，那么a(3),a(5),a(8)….所有闭包都共享这个值 什么时候使用闭包？ 一般来说，可以将过程分成两部分或更多部分都进行工厂化的时候，就适合闭包(实际上，有些地方直接将闭包称呼为工厂函数)。第一个部分是可以给自由变量批量绑定不同的值，第二部分是多个闭包函数可以共享第一步绑定后的自由变量。]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
